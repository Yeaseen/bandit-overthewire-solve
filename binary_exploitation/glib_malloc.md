# Malloc call in glib

This code deals with understanding how glib's allocator finds free chunk for malloc call using a first-fit algorithm which you might
have seen in your undergrad OS course. If a chunk is free and large enough, malloc will select this chunk. This could be exploited in a use-after-free or double-free situation. Uncomment a portion to run that portion.

````
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
        fprintf(stderr, "Allocating 2 buffers. They can be large, don't have to be fastbin.\n");
        char* a = malloc(0x512);
        char* b = malloc(0x256);
        char* c;

        fprintf(stderr, "1st malloc(0x512): %p\n", a);
        fprintf(stderr, "2nd malloc(0x256): %p\n", b);

        fprintf(stderr, "we could continue mallocing here...\n");

        fprintf(stderr, "now let's put a string at a that we can read later \"this is A!\"\n");
        strcpy(a, "this is A!");

        fprintf(stderr, "first allocation %p points to %s\n", a, a);

        fprintf(stderr, "Freeing the first one...\n");

        free(a);
        /*
        a=NULL;
        //If you don't make the pointer a null, then it could be exploitable via a use-after-free situation.
        */

        /*
        //Unnecessary double free will lead to segmentation fault.
        free(a);
        */

        fprintf(stderr, "We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n", a);
        fprintf(stderr, "So, let's allocate 0x500 bytes\n");

        c = malloc(0x500);

        fprintf(stderr, "3rd malloc(0x500): %p\n", c);

        fprintf(stderr, "And put a different string here, \"this is C!\"\n");
        strcpy(c, "this is C!");

        fprintf(stderr, "3rd allocation %p points to %s\n", c, c);

        fprintf(stderr, "first allocation %p points to %s\n", a, a);

        fprintf(stderr, "If we reuse the first allocation, it now holds the data from the third allocation.\n");
}```

````
